#' Return the scaled transcript counts for a set of genes.
#'
#' @param sleuth_obj An existing Sleuth object as generated by sleuth_prep() and fit by sleuth_fit().
#' @param genes A vector containing gene names as strings that should be returned.
#'
#' @return Filtered scaled transcript counts for a specific set of genes.
#' @export
#' @examples
#' # Given a Sleuth object, retrive the filtered scaled transcript counts for all the sample for a given gene list.
#' filtered_scaled_transcript_counts(so_nominal, "ABH1")
filtered_scaled_transcript_counts <- function(sleuth_obj, genes) {
  if (sleuth_obj$gene_mode == TRUE) {
    # Obtain est_counts for all genes from the sleuth_obj
    scaled_trancript_counts <-
      sleuth_obj$obs_norm_filt %>% mutate(est_counts = scaled_reads_per_base * sleuth_obj$est_counts_sf)
    
    # Get all the transcripts for the specific gene
    gene_transcript_df <-
      sleuth_obj$target_mapping[sleuth_obj$target_mapping$ext_gene %in% genes,]
    
    # Filter all the transcript est_counts based on the gene_transcript_df
    scaled_trancript_counts <-
      scaled_trancript_counts[scaled_trancript_counts$target_id %in% gene_transcript_df$ext_gene,]
    colnames(scaled_trancript_counts)[2] <- "ext_gene"
    scaled_trancript_counts <-
      right_join(gene_transcript_df, scaled_trancript_counts, by = "ext_gene")
  }
  
  else {
    # If sleuth object gene agg is false:
    if (is.null(sleuth_obj$gene_column)) {
      # Obtain est_counts for all genes from the sleuth_obj
      scaled_trancript_counts <-
        sleuth_obj$obs_norm_filt %>% mutate(est_counts = est_counts * sleuth_obj$est_counts_sf)
      
      # Get all the transcripts for the specific gene
      gene_transcript_df <-
        sleuth_obj$target_mapping[sleuth_obj$target_mapping$ext_gene %in% genes,]
      
      # Filter all the transcript est_counts based on the gene_transcript_df
      scaled_trancript_counts <-
        scaled_trancript_counts[scaled_trancript_counts$target_id %in% gene_transcript_df$target_id,]
      scaled_trancript_counts <-
        right_join(gene_transcript_df, scaled_trancript_counts, by = "target_id")
    }
    
    else {
      # Obtain est_counts for all genes from the sleuth_obj
      scaled_trancript_counts <-
        sleuth_obj$obs_norm_filt %>% mutate(est_counts = est_counts * sleuth_obj$est_counts_sf)
      
      # Get all the transcripts for the specific gene
      gene_transcript_df <-
        sleuth_obj$target_mapping[sleuth_obj$target_mapping$ext_gene %in% genes,]
      
      gene_transcript_df <- gene_transcript_df[-1]
      colnames(gene_transcript_df) <- c("target_id", "ext_gene")
      scaled_trancript_counts <-
        scaled_trancript_counts[scaled_trancript_counts$target_id %in% gene_transcript_df$target_id,]
      scaled_trancript_counts <-
        right_join(gene_transcript_df, scaled_trancript_counts, by = "target_id")
    }
  }
  # Confirm that the transcripts based on the selected gene do exist in the sleuth_obj
  if (any(is.na(scaled_trancript_counts))) {
    return("Check to confirm that the gene list is correct.")
  }
  
  return(scaled_trancript_counts)
}

#' Run a Kruskal-Wallis One-Way ANOVA on non-parametric data at the isoform level
#' for a selected gene. The quantile of data the test is run upon is calculated
#' from the the est_counts of all the data and the resulting value is used to
#' filter based upon the mean of the est_counts for each individual transcript.
#' For example, for a quantile probability of 0.25, the function will determine
#' the quantile probability for 0.25 and assume this value to be 50. The
#' function will then determine the mean est_counts for each transcript of the
#' gene and if the mean is greater than the quantile calculated value of 50, it
#' will be included when running the test.
#'
#' @param sleuth_obj An existing Sleuth object as generated by sleuth_prep() and fit by sleuth_fit().
#' @param gene The name of a gene as a string to asses the isoform expression level between samples.
#' @param iqf A numeric value between 0 and 1 (inclusive) to denote the quantile of data to run the test upon.
#' @param threshold A numeric value for the p-value cutoff when running the resulting pairwise comparison.
#'
#' @return Results of a kruskal-wallis test at the isoform level.
#' @export
#' @examples
#' # Given a Sleuth object, run the Kruskal-Wallis test for the est_counts by sample metadata.
#' sleuth_kruskal_wallis(so_nominal, "ABH1", "tissue", iqf = 0.25)
sleuth_kruskal_wallis <-
  function(sleuth_obj,
           gene,
           iqf = 0,
           threshold = 0.05) {
    if (length(gene) >= 2) {
      return("Ensure the gene parameter contains only a single gene.")
    }
    
    # Retrieve the scaled transcript counts for the gene passed to the function
    scaled_trancript_counts <-
      filtered_scaled_transcript_counts(sleuth_obj = sleuth_obj, genes = gene)
    
    # Create a new column with a factor groupings
    s2c_df <- sleuth_obj$sample_to_covariates
    colNames = colnames(s2c_df[, -1])
    s2c_df$pasted <-
      apply(
        s2c_df[, colNames, drop = F],
        MARGIN = 1,
        FUN = function(i)
          paste(i, collapse = "_")
      )
    
    # Merge the scaled transcript counts and the s2c_df
    scaled_trancript_counts <-
      left_join(s2c_df, scaled_trancript_counts)
    
    # Create a named list with the format (transcript name, mean est_counts) for each transcript
    transcript_count_mean <- list()
    for (transcript in unique(scaled_trancript_counts$target_id)) {
      count_mean <-
        mean(scaled_trancript_counts[scaled_trancript_counts$target_id == transcript, "est_counts"])
      transcript_count_mean[[transcript]] <-
        c(transcript_count_mean[[transcript]], count_mean)
    }
    
    # Calculate the quantile value based on all the est_counts for every transcript for the selected gene with a probability of the user selected iqf parameter
    quant_val <-
      quantile(scaled_trancript_counts$est_counts, probs = iqf)
    
    # Remove all the transcripts that do not have an average est_count that is greater than the quant_val
    scaled_trancript_counts <-
      scaled_trancript_counts[scaled_trancript_counts$target_id %in% c(names(transcript_count_mean[transcript_count_mean > quant_val])),]
    
    # Calculate the quantile based upon the user-selected iqf that the means that must be calculated must exceed
    kw_stat <-
      kruskal.test(est_counts ~ sample, data = scaled_trancript_counts)
    print(kw_stat)
    
    # Run the wilcox pairwise test
    print(sleuth_wilcox_pairwise(scaled_trancript_counts, cutoff = threshold))
    
    return (scaled_trancript_counts)
  }

#' Run a Wilcox pairwise comparison for a group across est_counts.
#'
#' @param data An existing Sleuth object as generated by sleuth_prep() and fit by sleuth_fit().
#' @param cutoff The p-value cutoff to be used for the letter based output.
#'
#' @return Results of a pairwise Wilcox test to identify the significantly different groups given as letters, where different letters indicate significance.
#' @examples
#' # Given a dataframe that contains est_counts for a particular gene and grouping information, run the Wilcox pairwise comparison of the est_counts factor between the selected group.
#' sleuth_wilcox_pairwise(scaled_transcript_counts, "sex")
sleuth_wilcox_pairwise <- function(data, cutoff = 0.05) {
  pw_w_test <-
    pairwise.wilcox.test(data$est_counts, scaled_trancript_counts$factor_group, p.adjust.method = "BH")
  pw_w_test$p.value[which(is.nan(pw_w_test$p.value))] <- 1
  pw_w_test_letter <-
    multcompLetters(
      fullPTable(pw_w_test$p.value),
      compare = "<",
      threshold = cutoff,
      Letters = letters,
      reverse = FALSE
    )
  print(pw_w_test)
  return(pw_w_test_letter$Letters)
}

#' Calculate and return the sum of the RSS values avalible for the model, model
#' factors, and the lrt factors (if the LRT was ran).
#'
#' @param sleuth_obj An existing Sleuth object as generated by sleuth_prep() and fit by sleuth_fit().
#' @param include_wald Boolean value to indicate if the wald test results should be returned. Default is FALSE.
#' @param include_lrt Boolean value to indicate if the wald test results should be returned. Default is FALSE.
#' @param return_df Boolean value to indicate if the result should be returned as a dataframe or a list. If FALSE, then return just the values.
#'
#' @return Dataframe or characters with all the RSS values for a given sleuth_object.
#' @export
#' @examples
#' # Given a Sleuth object, retrieve the RSS values.
#' sleuth_model_rss(so_nominal)
sleuth_model_rss <-
  function(sleuth_obj,
           include_wald = FALSE,
           include_lrt = FALSE,
           return_df = FALSE) {
    RSS_df <- data.frame(Parameters = "", RSS = 0)
    
    # Get the model RSS values
    for (model in names(sleuth_obj$fits)) {
      model_RSS <- sum(sleuth_obj$fits[[model]][["summary"]][, 2])
      RSS_df[nrow(RSS_df) + 1,] <- c(model, model_RSS)
    }
    
    # Check the RSS values for each test for each fit for all the factors
    for (stat_test in names(sleuth_obj$tests)) {
      if (include_wald) {
        if (stat_test == "wt") {
          for (extra_fits in names(sleuth_obj$tests$wt)) {
            for (factor in names(sleuth_obj$tests$wt[[extra_fits]])) {
              factor_name <- paste(stat_test, extra_fits, factor, sep = '_')
              factor_RSS <-
                sum(sleuth_obj$tests$wt[[extra_fits]][[factor]][, 2])
              RSS_df[nrow(RSS_df) + 1,] <- c(factor_name, factor_RSS)
            }
          }
        }
      }
      
      if (include_lrt) {
        if (stat_test == "lrt") {
          for (factor in names(sleuth_obj$tests$lrt)) {
            factor_name <- paste(stat_test, factor, sep = '_')
            factor_RSS <- sum(sleuth_obj$tests$lrt[[factor]][, 6])
            RSS_df[nrow(RSS_df) + 1,] <- c(factor_name, factor_RSS)
          }
        }
      }
    }
    
    # Drop the extra row that was created at the beginning when making the RSS_df
    RSS_df <- RSS_df[-1,]
    
    if (return_df) {
      return(RSS_df)
    }
    else{
      return(RSS_df[, 2])
    }
  }
