# Additional pre-processing functions to complement Gumshoe for Sleuth analysis.

# Required libraries ----
# library(tidyverse)
# library(sleuth)
# library(biomaRt)


# Parameters ----
# Generate the necessary models for sleuth to run. There are five in total:
# model_nominal, model_quant_linear/log/exp, and model_two_binary_factors.

# Define the metadata files, associated models, and the corresponding model
# formula to be used. The `I` before the mathematical expressions makes the
# expression uninterpreted until Sleuth processes the model. NOTE: The order
# of the model data must be align with the model names.
# metadata_names <- c()
# model_names <- c()
# model_data <- c()


# Analysis data frame creation and metadata manipulation ----
# The analysis data file contains the metadata file name, the metadata file, the
# model names, and the model formula.
# analysis_data <- data.frame(metadata_name = metadata_names, metadata_file = tibble(list(metadata)), model_name = model_names, model_data = model_data)
# View(analysis_data)


# Functions ----
#' Automate the running of sleuth_prep and sleuth_fit on all provided metadata files and the associated models
#'
#' @param data A data frame containing metadata file name, metadata tiblle file, model names, and model formulae
#'
#' @return Sleuth object named using the associated metadata file name and processed with sleuth_prep() and sleuth_fit()
#' @export
#' @examples
#' # Given a sample data frame containing a metadata_file_name, metadata_file, model_name, and model_data (formulae),
#' # create a sleuth object that has been processed using sleuth_prep() followed by sleuth_fit()
#' sleuth_interpret(analysis_data)
sleuth_interpret <- function(data) {
    for (metadata_file_number in 1:length(data$metadata_name)) {
      metadata_file <- data.frame(data[metadata_file_number, 2])
      metadata_model_names <- unlist(strsplit(data$model_name[metadata_file_number], ","))
      metadata_model_formula <- unlist(strsplit(data$model_data[metadata_file_number], ","))
      
      for (metadata_model_number in 1:length(metadata_model_names)) {
        so_holder_variable <- sleuth_prep(metadata_file,
                                          as.formula(metadata_model_formula[metadata_model_number]),
                                          num_cores = 1)
        so_holder_variable <- sleuth_fit(so_holder_variable)
        
        sleuth_obj_name <- paste("so", metadata_model_names[metadata_model_number], sep = "_")
        
        assign(sleuth_obj_name, so_holder_variable, envir = .GlobalEnv)
      }
    }
  }

#' Automated function to run all possible Wald tests on a given Sleuth object and the fitted model
#'
#' @param sleuth_obj An existing Sleuth object as generated by sleuth_prep() and fit by sleuth_fit()
#'
#' @return Results of the Wald test assigned to the original Sleuth object input
#' @examples
#' # Given a Sleuth object, run a Wald test on all possible models as determined on the formula used to run sleuth_prep()
#' sleuth_test_wt(so)
sleuth_test_wt <- function(sleuth_obj) {
    sleuth_obj_name <- deparse(substitute(sleuth_obj))
    
    coeff <- colnames(sleuth_obj$design_matrix)
    
    for (model in coeff) {
      if (model != "(Intercept)") {
        sleuth_obj <- sleuth_wt(sleuth_obj, model)
        
        assign(sleuth_obj_name, sleuth_obj, envir = .GlobalEnv)
      }
    }
  }

#' Automated function to run all possible Likewise Ratio tests on a given Sleuth object with models derived from the original formula used to run sleuth_fit()
#'
#' @param sleuth_obj An existing Sleuth object as generated by sleuth_prep() and fit by sleuth_fit()
#'
#' @return Results of the Likewise Ratio test assigned to the original Sleuth object input
#' @export
#' @examples
#' # Given a Sleuth object, run a Likewise Ratio test on all possible models derived from the original formula used to run sleuth_prep()
#' sleuth_test_lrt(so)
sleuth_test_lrt <- function(sleuth_obj) {
    sleuth_obj_name <- deparse(substitute(sleuth_obj))
    
    formula_variables <- sleuth_obj$full_formula
    formula_variables <- all.vars(formula_variables)
    
    for (model in formula_variables) {
      remaining_variables <- paste(formula_variables[-(match(model, formula_variables))], collapse = "_")
      remaining_variables <- paste("no", remaining_variables, sep = "_")
      
      model <- paste("~", model, sep = "")
      
      sleuth_obj <- sleuth_fit(sleuth_obj, as.formula(model), fit_name = remaining_variables)
      sleuth_obj <- sleuth_lrt(sleuth_obj, remaining_variables, "full")
      assign(sleuth_obj_name, sleuth_obj, envir = .GlobalEnv)
    }
  }

#' Retrieve all target id's for a given data frame with a FDR <.05
#'
#' @param sleuth_res A data frame generated following running sleuth_results
#'
#' @return A list of target id's.
#' @export
#' @examples
#' # Given a Sleuth object, run a Likewise Ratio test on all possible models derived from the original formula used to run sleuth_prep
#' f05(wald_test_results)
f05 <- function(sleuth_res) {
    sleuth_res[which(sleuth_res$q < .05), ]
  }

#' Retrieve all results from a given Sleuth object following statistical testing
#'
#' @param sleuth_obj An existing Sleuth object as generated by sleuth_prep() and fit by sleuth_fit()
#' @param test The sleuth test to be analyzed using sleuth_results, can be either "wt" or "lrt". Defaults to "wt".
#'
#' @returns Firstly, newly generated variable containing resulting data from Wald or Likewise Ratio tests performed. Secondly, data frame containing data points with an FDR <.05
#' @export
#' @examples
#' # Given a Sleuth object and Boolean values of tests to run, perform the requested tests on all possible models for the given Sleuth object
#' sleuth_object_result(so, test = "lrt")
sleuth_object_result <- function(sleuth_obj, test = "wt") {
    coeff <- colnames(sleuth_obj$design_matrix)
    sleuth_obj_name <- deparse(substitute(sleuth_obj))
    sleuth_obj_name <- unlist(strsplit(sleuth_obj_name, "_"))
    sleuth_obj_name <- paste(sleuth_obj_name[c(2:length(sleuth_obj_name))], collapse = "_")
    
    if (test == "wt") {
      sig_target_ids <- NA
      sig_results <- NA
      for (model in coeff) {
        if (model != "(Intercept)") {
          wald_result <- sleuth_results(sleuth_obj, model, test_type = 'wt')
          rownames(wald_result) <- wald_result$target_id
          
          sig_target_ids <- unique(c(f05(wald_result), sig_target_ids))
          
          wald_model_name <- paste("wald", sleuth_obj_name, sep = "_")
          wald_model_name <- paste(wald_model_name, model, sep = "_")
          assign(wald_model_name, wald_result, envir = .GlobalEnv)
        }
      }
      
      for (model in coeff) {
        if (model != "(Intercept)") {
          sig_results <- c(wald_result[sig_target_ids, ], sig_results)
        }
      }
      sig_results <- sig_results[1:(length(sig_results) - 1)]
      wald_sig_name <- paste("wald_sig_results", sleuth_obj_name, sep = "_")
      assign(wald_sig_name, sig_results, envir = .GlobalEnv)
    }
    
    if (test == "lrt") {
      sig_target_ids <- NA
      sig_results <- NA
      for (model in names(sleuth_obj$tests[['lrt']])) {
        lrt_result <- sleuth_results(sleuth_obj, model, test_type = 'lrt')
        rownames(lrt_result) <- lrt_result$target_id
        
        sig_target_ids <- unique(c(f05(lrt_result), sig_target_ids))
        
        lrt_model_name <- paste("lrt", sleuth_obj_name, sep = "_")
        lrt_model_name <- paste(lrt_model_name, model, sep = "_")
        assign(lrt_model_name, lrt_result, envir = .GlobalEnv)
      }
      for (model in names(sleuth_obj$tests[['lrt']])) {
        sig_results <- c(lrt_result[sig_target_ids, ], sig_results)
      }
      sig_results <- sig_results[1:(length(sig_results) - 1)]
      lrt_sig_name <- paste("lrt_sig_results", sleuth_obj_name, sep = "_")
      assign(lrt_sig_name, sig_results, envir = .GlobalEnv)
    }
  }


#' Convert a given list of ensemble transcript id's into \code{ensembl_transcript_id}'s, \code{external_gene_name}'s, \code{ensembl_gene_id}'s, and the original transcript.id
#'
#' @param sig_results A data frame or list containing ensemble transcript id's
#' @param entire_gene_name Set to TRUE if the non-abbreviated gene names is required.
#'
#' @return Converts the original data frame or list into a data frame with columns corresponding to \code{ensembl_transcript_id}'s, \code{external_gene_name}'s, \code{ensembl_gene_id}'s, and the original transcript.id
#' @export
#' @examples
#' # Convert a data frame of ensemble transcript id's
#' ensemble_to_id(wald_sig_results)
ensemble_to_id <- function(sig_results, entire_gene_name = FALSE) {
  if (!exists("mart")) {
    print("Function requires a BioMart database and dataset. Run the following command to create the required `mart` object:")
    print("")
    print('mart <- useMart("ensembl", dataset = "mmusculus_gene_ensembl")')
  }
  
  else {
    sig_results$new_column <- gsub("\\.[0-9]*$", "", sig_results$target_id)
    
    names(sig_results)[1] <- "transcript.version"
    names(sig_results)[12] <- "transcript.id"
    
    ensemble_convert <- getBM(attributes = c("ensembl_transcript_id","external_gene_name","ensembl_gene_id","description"),
                              filters = "ensembl_transcript_id",
                              values = sig_results$transcript.id,
                              mart = mart)
    
    sig_results <- cbind(sig_results, ensemble_convert)
    if (entire_gene_name) {
      sig_results <- sig_results[, c(14, 1, 2:16)]
    }
    else {
      sig_results <- sig_results[, c(14, 1, 2:15)]
    }
    assign("annotated_sig_results", sig_results, envir = .GlobalEnv)
  }
}