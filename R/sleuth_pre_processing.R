# ----------------------------
# Libraries
# ----------------------------
# library(tidyverse)
# library(sleuth)
# library(biomaRt)


# ----------------------------
# Parameters
# ----------------------------
# Generate the necessary models for sleuth to run. There are five in total:
# model_nominal, model_quant_linear/log/exp, and model_two_binary_factors.

# Define the metadata files, associated models, and the corresponding model
# formula to be used. The `I` before the mathematical expressions makes the
# expression uninterpreted until Sleuth processes the model. NOTE: The order
# of the model data must be align with the model names.
# metadata_names <- c()
# model_names <- c()
# model_data <- c()


# ----------------------------
# Analysis data frame creation and metadata manipulation below
# ----------------------------
# The analysis data file contains the metadata file name, the metadata file, the
# model names, and the model formula.
# analysis_data <- data.frame(metadata_name = metadata_names, metadata_file = tibble(list(metadata)), model_name = model_names, model_data = model_data)
# View(analysis_data)


# ----------------------------
# Functions
# ----------------------------
#' Automate the running of sleuth_prep and sleuth_fit on all provided metadata files and the associated models
#'
#' @param data A data frame containing metadata file name, metadata tiblle file, model names, and model formulae
#'
#' @return Sleuth object named using the associated metadata file name and processed with sleuth_prep() and sleuth_fit()
#' @export
#' @examples
#' # Given a sample data frame containing a metadata_file_name, metadata_file, model_name, and model_data (formulae),
#' # create a sleuth object that has been processed using sleuth_prep() followed by sleuth_fit()
#' sleuth_interpret(analysis_data)
sleuth_interpret <- function(data){
  for (metadata_file_number in 1:length(data$metadata_name)){

    metadata_file <- data.frame(data[metadata_file_number, 2])
    metadata_model_names <- unlist(strsplit(data$model_name[metadata_file_number], ","))
    metadata_model_formula <- unlist(strsplit(data$model_data[metadata_file_number], ","))

    for (metadata_model_number in 1:length(metadata_model_names)){
      # cat("Metadata file name:", data[metadata_file_number, 1])
      # print("")
      # cat("Model for metadata:", metadata_model_names[metadata_model_number])
      # print("")
      # cat("Length of models:", length(metadata_model_formula))
      # print("")
      # cat("Formula for model:", metadata_model_formula[metadata_model_number])
      # print("")
      # print("-----------")
      # so_holder_variable <- c(as.vector(data[metadata_file_number, 1]), as.vector(metadata_model_formula[metadata_model_number]))
      # sleuth_obj_name <- paste("so", metadata_model_names[metadata_model_number], sep = "_")
      # assign(sleuth_obj_name, so_holder_variable, envir = .GlobalEnv)
      so_holder_variable <- sleuth_prep(metadata_file, as.formula(metadata_model_formula[metadata_model_number]), num_cores=1)
      so_holder_variable <- sleuth_fit(so_holder_variable)
      sleuth_obj_name <- paste("so", metadata_model_names[metadata_model_number], sep = "_")
      assign(sleuth_obj_name, so_holder_variable, envir = .GlobalEnv)
    }
  }
}

#' Automated function to run all possible Wald tests on a given Sleuth object and the fitted model
#'
#' @param sleuth_obj An existing Sleuth object as generated by sleuth_prep() and fit by sleuth_fit()
#'
#' @return Results of the Wald test assigned to the original Sleuth object input
#' @examples
#' # Given a Sleuth object, run a Wald test on all possible models as determined on the formula used to run sleuth_prep()
#' sleuth_test_wt(so)
sleuth_test_wt <- function(sleuth_obj){
  sleuth_obj_name <- deparse(substitute(sleuth_obj))
  # assign("sleuth_obj_name", sleuth_obj_name, envir = .GlobalEnv)
  # cat("SO object name:", sleuth_obj_name)
  # print("")
  coeff <- colnames(sleuth_obj$design_matrix)
  # cat("Coeff are:", coeff)
  for (model in coeff){
    # print(model != "(Intercept)")
    if (model != "(Intercept)"){
      # print("PASSED")
      # print("")
      # cat("Running wt for model:", model)
      sleuth_obj <- sleuth_wt(sleuth_obj, model)

      assign(sleuth_obj_name, sleuth_obj, envir = .GlobalEnv)
    }
  }
}

#' Automated function to run all possible Likewise Ratio tests on a given Sleuth object with models derived from the original formula used to run sleuth_fit()
#'
#' @param sleuth_obj An existing Sleuth object as generated by sleuth_prep() and fit by sleuth_fit()
#'
#' @return Results of the Likewise Ratio test assigned to the original Sleuth object input
#' @export
#' @examples
#' # Given a Sleuth object, run a Likewise Ratio test on all possible models derived from the original formula used to run sleuth_prep()
#' sleuth_test_lrt(so)
sleuth_test_lrt <- function(sleuth_obj){
  sleuth_obj_name <- deparse(substitute(sleuth_obj))

  # TODO: We then run sleuth_lrt on the sleuth_obj based on the new sleuth_fit
  # and save this to the sleuth_obj. So at the very end just assign the sleuth_obj
  # to the actual object or will it work by just referring to the sleuth_obj as
  # the true object??
  formula_variables <- sleuth_obj$full_formula
  formula_variables <- all.vars(formula_variables)

  # LRT
  # Wald is good when you have a good handle on the std btwn replicates. LRT is
  # better in other cases cause it has a less strict assumption of std.
  for (model in formula_variables){
    remaining_variables <- paste(formula_variables[-(match(model, formula_variables))], collapse = "_")
    remaining_variables <- paste("no", remaining_variables, sep = "_")

    model <- paste("~", model, sep ="")

    sleuth_obj <- sleuth_fit(sleuth_obj, as.formula(model), fit_name = remaining_variables)
    sleuth_obj <- sleuth_lrt(sleuth_obj, remaining_variables, "full")
    assign(sleuth_obj_name, sleuth_obj, envir = .GlobalEnv)
  }
}

#' Retrieve all target id's for a given data frame with a FDR <.05
#'
#' @param sleuth_res A data frame generated following running sleuth_results
#'
#' @return A list of target id's.
#' @export
#' @examples
#' # Given a Sleuth object, run a Likewise Ratio test on all possible models derived from the original formula used to run sleuth_prep
#' f05(wald_test_results)
f05 <- function(sleuth_res){
  # The q in the following line is the FDR. So the significant samples are those
  # with a FDR <.05.
  sleuth_res$target_id[which(sleuth_res$q<.05)]
}

#' Retrieve all results from a given Sleuth object following statistical testing
#'
#' @param sleuth_obj An existing Sleuth object as generated by sleuth_prep() and fit by sleuth_fit()
#' @param test The sleuth test to be analyzed using sleuth_results, can be either "wt" or "lrt". Defaults to "wt".
#'
#' @returns Firstly, newly generated variable containing resulting data from Wald or Likewise Ratio tests performed. Secondly, data frame containing data points with an FDR <.05
#' @export
#' @examples
#' # Given a Sleuth object and Boolean values of tests to run, perform the requested tests on all possible models for the given Sleuth object
#' sleuth_object_result(so, test = "lrt")
sleuth_object_result <- function(sleuth_obj, test = "wt"){
  coeff <- colnames(sleuth_obj$design_matrix)
  sleuth_obj_name <- deparse(substitute(sleuth_obj))
  sleuth_obj_name <- unlist(strsplit(sleuth_obj_name, "_"))
  sleuth_obj_name <- paste(sleuth_obj_name[c(2:length(sleuth_obj_name))], collapse = "_")

  # This for loop will extract all of the results from the wt.
  if (test == "wt"){
    sig_target_ids <- NA
    sig_results <- NA
    for (model in coeff){
      # print(model != "(Intercept)")
      if (model != "(Intercept)"){
        # cat(model)
        # print("")
        wald_result <- sleuth_results(sleuth_obj, model, test_type = 'wt')
        rownames(wald_result) <- wald_result$target_id

        sig_target_ids <- unique(c(f05(wald_result), sig_target_ids))

        wald_model_name <- paste("wald", sleuth_obj_name, sep = "_")
        wald_model_name <- paste(wald_model_name, model, sep ="_")
        assign(wald_model_name, wald_result, envir = .GlobalEnv)
        # cat("Assigned model result to the following object:", wald_model_name)
      }
    }
    for (model in coeff){
      if (model != "(Intercept)"){
        sig_results <- c(wald_result[sig_target_ids,], sig_results)
      }
    }
    sig_results <- sig_results[1:(length(sig_results)-1)]
    wald_sig_name <- paste("wald_sig_results", sleuth_obj_name, sep = "_")
    assign(wald_sig_name, sig_results, envir = .GlobalEnv)
  }

  if (test == "lrt"){
    sig_target_ids <- NA
    sig_results <- NA
    for (model in names(sleuth_obj$tests[['lrt']])){
      lrt_result <- sleuth_results(sleuth_obj, model, test_type = 'lrt')
      rownames(lrt_result) <- lrt_result$target_id

      sig_target_ids <- unique(c(f05(lrt_result), sig_target_ids))

      lrt_model_name <- paste("lrt", sleuth_obj_name, sep = "_")
      lrt_model_name <- paste(lrt_model_name, model, sep ="_")
      assign(lrt_model_name, lrt_result, envir = .GlobalEnv)
    }
    for (model in names(sleuth_obj$tests[['lrt']])){
      sig_results <- c(lrt_result[sig_target_ids,], sig_results)

    }
    sig_results <- sig_results[1:(length(sig_results)-1)]
    lrt_sig_name <- paste("lrt_sig_results", sleuth_obj_name, sep = "_")
    assign(lrt_sig_name, sig_results, envir = .GlobalEnv)
  }
}

# TODO: Finish this code
#' Retrieve all results from a given Sleuth object following statistical testing
#'
#' @param sleuth_obj An existing Sleuth object as generated by sleuth_prep() and fit by sleuth_fit()
#' @param test The sleuth test to be analyzed using sleuth_results, can be either "wt" or "lrt". Defaults to "wt".
#'
#' @returns Firstly, newly generated variable containing resulting data from Wald or Likewise Ratio tests performed. Secondly, data frame containing data points with an FDR <.05
#' @export
#' @examples
#' # Given a Sleuth object and Boolean values of tests to run, perform the requested tests on all possible models for the given Sleuth object
#' sleuth_object_result(so, test = "lrt")
sleuth_optimize <- function(){
  for (sample in metadata$sample){
  }
}


# TODO: Run document on the file from pkg roxygen2 and see if I can get the markdown
#' Convert a given list of ensemble transcript id's into \code{ensembl_transcript_id}'s, \code{external_gene_name}'s, \code{ensembl_gene_id}'s, and the original transcript.id
#'
#' @param sig_results A data frame or list containing ensemble transcript id's
#'
#' @return Converts the original data frame or list into a data frame with columns corresponding to \code{ensembl_transcript_id}'s, \code{external_gene_name}'s, \code{ensembl_gene_id}'s, and the original transcript.id
#' @export
#' @examples
#' # Convert a data frame of ensemble transcript id's
#' ensemble_to_id(wald_sig_results)
ensemble_to_id <- function(sig_results){
  # if (!exists("mart")){
  #   Mart <- useMart("ensembl", dataset = "mmusculus_gene_ensembl")
  #   assign(mart, Mart, eniv = .GlobalEnv)
  # }

  sig_transcripts <- data.frame(sig_results$target_id, gsub("\\.[0-9]*$", "", sig_results$target_id))

  names(sig_transcripts)[1] <- "transcript.version"
  names(sig_transcripts)[2] <- "transcript.id"

  ensemble_convert <- getBM(attributes=c("ensembl_transcript_id","external_gene_name","ensembl_gene_id"),
                            filters = "ensembl_transcript_id",
                            values = sig_transcripts$transcript.id,
                            mart = mart)

  annotLookup <- data.frame(
    sig_transcripts$transcript.version[match(ensemble_convert$ensembl_transcript_id, sig_transcripts$transcript.id)],
    ensemble_convert)

  names(annotLookup)[1] <- "original_id"
  assign("annotLookup", annotLookup, envir = .GlobalEnv)
}
